# Crash 游戏详细设计文档

## 1. 游戏概述

Crash 是一个多人实时竞猜游戏，玩家下注后观察倍率上升，在崩溃前及时兑现获得收益。游戏的核心是一个不断上升的倍率曲线，会在某个随机点突然崩溃。

### 1.1 游戏特点
- 多人同步游戏，所有玩家看到相同的倍率曲线
- 实时性要求高，需要毫秒级的响应
- 支持自动兑现功能
- 可证明公平机制

## 2. 开发思路

### 2.1 架构选择
由于 Crash 是多人游戏，与现有的单人游戏架构不同，需要全局唯一的游戏实例、统一的游戏状态管理和实时广播机制。最终选择直接在 Service 层实现，不引入额外的抽象层。

### 2.2 技术方案
状态管理采用 Service 内部维护全局游戏状态的方式。实时通信通过 WebSocket 长连接配合广播机制实现。并发控制使用互斥锁保护共享状态。时间同步由服务端统一计时，客户端只负责展示。

## 3. 核心实现

### 3.1 游戏循环

游戏在服务启动时自动开始，24/7 不间断运行。系统启动后立即创建游戏实例并启动游戏循环协程。

游戏分为三个阶段循环：
1. **下注阶段**（10秒）：接受玩家下注，期间玩家可以自由下注或取消
2. **飞行阶段**（变长）：倍率从 1.0 开始上升直到达到预定的崩溃点
3. **等待阶段**（5秒）：展示结果，清理数据，准备下一轮

### 3.2 崩溃点算法

使用可证明公平的算法生成崩溃点。算法使用服务器种子、客户端种子和递增的 nonce 值，通过 HMAC-SHA256 生成哈希值，然后转换为浮点数。最终通过公式计算出崩溃点，确保 RTP 为 97%。约有 3% 的概率会立即崩溃在 1.0 倍。

### 3.3 倍率更新

飞行阶段每 100 毫秒更新一次倍率。倍率按照指数函数增长，确保曲线平滑上升。每次更新后系统会检查是否有玩家设置的自动兑现需要触发，然后向所有已连接的玩家广播最新倍率。

## 4. 消息通信

### 4.1 消息格式

系统使用 Protobuf 定义消息结构，运行时转换为 JSON 格式便于调试。每条消息包含 action 字段表示消息类型，payload 字段包含具体数据。

### 4.2 广播机制

游戏消息只向已认证的用户广播。系统维护一个已认证玩家的连接映射表，广播时遍历这个映射表向每个连接发送消息。这样可以防止未登录用户接收到游戏数据。

## 5. 下注处理

### 5.1 下注验证

玩家下注时系统会进行多重验证。首先检查当前游戏阶段是否为下注阶段，然后验证下注金额是否在允许范围内，接着确认玩家余额是否充足，最后检查槽位数量是否超过限制。只有通过所有验证才会接受下注。

### 5.2 多槽位投注机制

Crash 游戏支持玩家使用最多 3 个独立槽位进行投注：

1. **单次单槽位投注**：每次 PLACE_BET 请求只针对一个槽位
   - 请求参数：`{ slotId: 1, amount: "100" }`
   - 玩家需要分别发起 3 次请求来投注 3 个槽位
2. **槽位占用检查**：投注前检查该槽位是否已有投注，避免重复投注
3. **独立交易记录**：每个槽位的投注对应聚合器的一条 PlaceBet 交易
4. **独立生命周期**：每个槽位可以单独兑现、单独取消
5. **数据一致性**：每个槽位的 GameResult 记录对应一条聚合器交易记录

### 5.3 自动兑现

玩家可以在下注时设置自动兑现倍率。服务端在飞行阶段持续监控当前倍率，当达到玩家设定的目标倍率时自动执行兑现操作。这个过程完全在服务端进行，不受网络延迟影响。

## 6. 运行流程

### 6.1 服务启动
服务启动时初始化 Crash 游戏服务实例，立即启动游戏循环协程开始第一轮游戏，同时注册 WebSocket 消息处理器准备接收玩家请求。

### 6.2 玩家加入
玩家通过 WebSocket 连接到服务器，发送认证信息验证身份。认证成功后系统更新玩家连接映射表，并向玩家发送当前游戏状态，让玩家能够立即看到游戏进行情况。

### 6.3 下注流程
玩家在下注阶段发送下注请求，服务端验证请求合法性并扣除相应余额。系统将下注信息记录到活跃下注列表中，然后向所有玩家广播有新玩家加入的消息。

### 6.4 兑现流程
玩家可以手动发送兑现请求，或者等待自动兑现触发。系统根据当前倍率计算获胜金额，更新玩家余额，然后向所有玩家广播兑现信息。

### 6.5 回合结束
当倍率达到预定的崩溃点时游戏结束。系统处理所有未兑现的下注，这些下注将全部判定为亏损。然后广播回合结果，包括崩溃点、赢家列表和输家列表。最后进入等待阶段准备下一轮。

## 7. 状态管理

### 7.1 游戏状态

系统维护全局的游戏状态，包括当前游戏阶段、当前回合信息、所有活跃下注和当前倍率。这些状态在整个游戏过程中不断更新。

### 7.2 并发安全

由于多个玩家可能同时操作，系统使用读写锁保护共享状态。读操作使用读锁，允许并发读取。写操作使用写锁，确保数据修改的原子性。

## 8. 客户端交互

### 8.1 连接流程
客户端首先建立 WebSocket 连接，然后发送包含 JWT token 的认证信息。认证成功后接收服务端推送的当前游戏状态，之后持续接收游戏广播消息。

### 8.2 消息处理
客户端需要处理阶段变更消息了解游戏进入哪个阶段，处理倍率更新消息实时显示倍率变化，处理玩家状态更新了解其他玩家的下注和兑现情况，处理回合结束消息显示最终结果。

### 8.3 断线重连
如果玩家断线，服务端会保持游戏状态和玩家的下注信息。客户端重连后可以通过获取状态接口恢复到断线前的状态，未完成的下注继续有效。

## 9. 性能优化

### 9.1 广播优化
系统采用批量发送策略减少网络调用次数。使用缓冲通道避免发送阻塞影响游戏主循环。对于发送失败的连接采用异步处理，不影响其他玩家。

### 9.2 状态查询
常用数据如当前倍率、游戏阶段等使用缓存减少锁竞争。操作时尽量减少锁的持有时间。将读操作和写操作分离，提高并发性能。

## 10. 总结

Crash 游戏的实现重点在于实时性、公平性、同步性和可靠性。通过合理的架构设计，成功将多人游戏集成到现有的单人游戏框架中。系统能够支持大量玩家同时参与，提供流畅的游戏体验。